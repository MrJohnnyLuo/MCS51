C51 COMPILER V9.02   MAIN                                                                  03/29/2020 01:25:19 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: D:\Program Files (x86)\Keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*
   2          ************************
   3          ***变更正计数为倒计数***
   4          ************************
   5          */
   6          
   7          #include<reg52.h>
   8          
   9          sbit ADDR0 = P1^0;
  10          sbit ADDR1 = P1^1;
  11          sbit ADDR2 = P1^2;
  12          sbit ADDR3 = P1^3;
  13          sbit ENLED = P1^4;
  14          
  15          unsigned char code LedChar[] = {        //数码管显示字符转换表
  16                  0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8,
  17                  0x80, 0x90, 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E
  18          };
  19          unsigned char LedBuff[6] = {    //数码管显示缓冲区，初值0xFF确保启动时都不亮
  20                  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
  21          };
  22          unsigned char i = 0;            //动态扫描的索引
  23          unsigned int cnt = 0;           //记录T1中断次数
  24          unsigned char flag1s = 0;       //1秒定时标志
  25          
  26          void main()
  27          {
  28   1              unsigned char j = 0;    //循环变量
  29   1              unsigned long sec = 1000000;    //记录经过的秒表，倒计时初值为999999+1
  30   1              unsigned char buf[6] = {        //中间转换缓冲区
  31   1                      0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
  32   1              };
  33   1              
  34   1              ENLED = 0;              //使能U3
  35   1              ADDR3 = 1;              //因为需要动态改变ADDR0-2的值，所以不需要再初始化了
  36   1              TMOD = 0x10;    //设置T1为模式1
  37   1              TH1 = 0xFC;             //为T1赋初值0xFC67，定时1ms
  38   1              TL1 = 0x67;
  39   1              TR1 = 1;                //使能T1中断
  40   1              EA = 1;                 //使能总中断
  41   1              ET1 = 1;                //启动T1
  42   1      
  43   1              while(1)
  44   1              {
  45   2                      if(flag1s == 1)         //判断1秒定时标志
  46   2                      {
  47   3                              flag1s = 0;             //1秒定时标志清零
  48   3                              sec--;                  //秒计数自减1
  49   3                              //将sec按十进制位从低到高依次提取到buf数组中
  50   3                              buf[0] = sec%10;
  51   3                              buf[1] = sec/10%10;
  52   3                              buf[2] = sec/100%10;
  53   3                              buf[3] = sec/1000%10;
  54   3                              buf[4] = sec/10000%10;
  55   3                              buf[5] = sec/100000%10;
C51 COMPILER V9.02   MAIN                                                                  03/29/2020 01:25:19 PAGE 2   

  56   3                              //从最高为开始，遇到0不显示，遇到非0退出循环
  57   3                              for(j=5; j>=1; j--)
  58   3                              {
  59   4                                      if(buf[j] == 0)
  60   4                                              LedBuff[j] = 0xFF;
  61   4                                      else
  62   4                                              break;
  63   4                              }
  64   3                              //将剩余的有效数字位如实转换
  65   3                              for(; j>=0; j--)        //for()起始未对j操作，j即保持上个循环结束时的值
  66   3                              {
  67   4                                      LedBuff[j] = LedChar[buf[j]];
  68   4                                      if(j == 0)
  69   4                                              break;
  70   4                              }
  71   3                      }
  72   2              }
  73   1      }
  74          /* 定时器1中断服务函数 */
  75          void InterruptTime1() interrupt 3
  76          {
  77   1              TH1 = 0xFC;             //重新加载初值
  78   1              TL1 = 0x67;
  79   1              cnt++;                  //中断次数计数值加1
  80   1              if(cnt >= 1000)         //中断1000次即1秒
  81   1              {
  82   2                      cnt = 0;                //清零计数值以重新开始下1秒计时
  83   2                      flag1s = 1;             //设置1秒定时标志为1
  84   2              }
  85   1              //以下代码完成数码管动态扫描刷新
  86   1              P0 = 0xFF;      //显示消隐
  87   1              switch(i)
  88   1              {
  89   2                      case 0: ADDR2=0; ADDR1=0; ADDR0=0; i++; P0=LedBuff[0]; break;
  90   2                      case 1: ADDR2=0; ADDR1=0; ADDR0=1; i++; P0=LedBuff[1]; break;
  91   2                      case 2: ADDR2=0; ADDR1=1; ADDR0=0; i++; P0=LedBuff[2]; break;
  92   2                      case 3: ADDR2=0; ADDR1=1; ADDR0=1; i++; P0=LedBuff[3]; break;
  93   2                      case 4: ADDR2=1; ADDR1=0; ADDR0=0; i++; P0=LedBuff[4]; break;
  94   2                      case 5: ADDR2=1; ADDR1=0; ADDR0=1; i=0; P0=LedBuff[5]; break;
  95   2                      default: break;
  96   2              }
  97   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    459    ----
   CONSTANT SIZE    =     22    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     10      11
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
