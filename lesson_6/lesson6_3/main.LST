C51 COMPILER V9.02   MAIN                                                                  03/27/2020 22:13:32 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: D:\Program Files (x86)\Keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*
   2          ******************************************
   3          *** 基于中断带消隐的数码管动态显示示例 ***
   4          ******************************************
   5          */
   6          
   7          #include<reg52.h>
   8          
   9          sbit ADDR0 = P1^0;
  10          sbit ADDR1 = P1^1;
  11          sbit ADDR2 = P1^2;
  12          sbit ADDR3 = P1^3;
  13          sbit ENLED = P1^4;
  14          
  15          unsigned char code LedChar[] = {        //数码管显示字符转换表
  16                  0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8,
  17                  0x80, 0x90, 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E
  18          };
  19          unsigned char LedBuff[6] = {    //数码管显示缓冲区，初值0xFF确保启动时都不亮
  20                  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
  21          };
  22          
  23          unsigned char i = 0;            //动态扫描的索引
  24          unsigned int cnt = 0;           //记录T0中断次数
  25          unsigned char flag1s = 0;       //1秒定时标志
  26          
  27          void main()
  28          {
  29   1              unsigned long sec = 0;  //记录经过的秒数
  30   1              
  31   1              ENLED = 0;              //使能U3，选择控制数码管
  32   1              ADDR3 = 1;              //因为需要动态改变ADDR0-2的值，所以不需要再初始化了
  33   1              TMOD = 0x01;    //设置T0为模式1
  34   1              TH0 = 0xFC;             //为T0赋初值0xFC67，定时1ms
  35   1              TL0 = 0x67;
  36   1              TR0 = 1;                //启动T0
  37   1              EA = 1;                 //使能总中断
  38   1              ET0 = 1;                //使能T0中断
  39   1      
  40   1              while(1)
  41   1              {
  42   2                      if(flag1s == 1)         //判断1秒定时标志
  43   2                      {
  44   3                              flag1s = 0;             //1秒定时标志清零
  45   3                              sec++;                  //秒计数自加1
  46   3                              //以下代码将sec按十进制位从低到高依次提取并转为数码管显示字符
  47   3                              LedBuff[0] = LedChar[sec%10];
  48   3                              LedBuff[1] = LedChar[sec/10%10];
  49   3                              LedBuff[2] = LedChar[sec/100%10];
  50   3                              LedBuff[3] = LedChar[sec/1000%10];
  51   3                              LedBuff[4] = LedChar[sec/10000%10];
  52   3                              LedBuff[5] = LedChar[sec/100000%10];
  53   3                      }
  54   2              }
  55   1      }
C51 COMPILER V9.02   MAIN                                                                  03/27/2020 22:13:32 PAGE 2   

  56          /* 定时器0中断服务函数 */
  57          void InterruptTime0() interrupt 1
  58          {
  59   1              TH0 = 0xFC;                     //重新加载初值
  60   1              TL0 = 0x67;
  61   1              cnt++;                          //中断次数计数值加1
  62   1              if(cnt >= 1000)         //中断1000次即1s
  63   1              {
  64   2                      cnt = 0;                //清零计数值以重新开始下1秒计时
  65   2                      flag1s = 1;             //设置1秒定时标志为1
  66   2              }
  67   1              //以下代码完成数码管动态扫描刷新
  68   1              P0 = 0xFF;      //显示消隐
  69   1              switch(i)
  70   1              {
  71   2                      case 0: ADDR2=0; ADDR1=0; ADDR0=0; i++; P0=LedBuff[0]; break;
  72   2                      case 1: ADDR2=0; ADDR1=0; ADDR0=1; i++; P0=LedBuff[1]; break;
  73   2                      case 2: ADDR2=0; ADDR1=1; ADDR0=0; i++; P0=LedBuff[2]; break;
  74   2                      case 3: ADDR2=0; ADDR1=1; ADDR0=1; i++; P0=LedBuff[3]; break;
  75   2                      case 4: ADDR2=1; ADDR1=0; ADDR0=0; i++; P0=LedBuff[4]; break;
  76   2                      case 5: ADDR2=1; ADDR1=0; ADDR0=1; i=0; P0=LedBuff[5]; break;
  77   2                      default: break;
  78   2              }
  79   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    437    ----
   CONSTANT SIZE    =     16    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     10       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
