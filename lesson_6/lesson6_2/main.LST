C51 COMPILER V9.02   MAIN                                                                  03/27/2020 21:29:55 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: D:\Program Files (x86)\Keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*
   2          ********************************************************
   3          ***     数码管动态显示原理示例(switch...case...语句示例) ***
   4          ********************************************************
   5          */
   6          
   7          #include<reg52.h>
   8          
   9          sbit ADDR0 = P1^0;
  10          sbit ADDR1 = P1^1;
  11          sbit ADDR2 = P1^2;
  12          sbit ADDR3 = P1^3;
  13          sbit ENLED = P1^4;
  14          
  15          unsigned char code LedChar[] = {        //数码管显示字符转换表
  16                  0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8,
  17                  0x80, 0x90, 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E
  18          };
  19          unsigned char LedBuff[6] = {    //数码管显示缓冲区，初值0xFF确保启动时都不亮
  20                  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
  21          };
  22          
  23          void main()
  24          {
  25   1              unsigned char i = 0;    //动态扫描的索引
  26   1              unsigned int cnt = 0;   //记录T0中断次数
  27   1              unsigned long sec = 0;  //记录经过的秒数
  28   1      
  29   1              ENLED = 0;              //使能U3，选择控制数码管
  30   1              ADDR3 = 1;              //因为需要动态改变ADDR0-2的值，所以不需要再初始化了
  31   1              TMOD = 0x01;    //设置T0为模式1 
  32   1              TH0 = 0xFC;             //为T0赋初值0xFC67，定时1ms
  33   1              TL0 = 0x67;
  34   1              TR0 = 1;                //启动T0
  35   1      
  36   1              while(1)
  37   1              {
  38   2                      if(TF0 == 1)            //判断T0是否溢出
  39   2                      {
  40   3                              TF0 = 0;                //T0溢出后，清零中断标志
  41   3                              TH0 = 0xFC;             //并重新赋初值
  42   3                              TL0 = 0x67;
  43   3                              cnt++;                  //计数值自加1
  44   3                              if(cnt >= 1000) //判断T0溢出是否达到1000次
  45   3                              {
  46   4                                      cnt = 0;        //达到1000次后计数值清零
  47   4                                      sec++;          //秒计数自加1
  48   4                                      //以下代码将sec按十进制位从低到高依次提取并转为数码管显示字符
  49   4                                      LedBuff[0] = LedChar[sec%10];
  50   4                                      LedBuff[1] = LedChar[sec/10%10];
  51   4                                      LedBuff[2] = LedChar[sec/100%10];
  52   4                                      LedBuff[3] = LedChar[sec/1000%10];
  53   4                                      LedBuff[4] = LedChar[sec/10000%10];
  54   4                                      LedBuff[5] = LedChar[sec/100000%10];
  55   4                              }
C51 COMPILER V9.02   MAIN                                                                  03/27/2020 21:29:55 PAGE 2   

  56   3                              //以下代码完成数码管动态扫描刷新
  57   3                              switch(i)
  58   3                              {
  59   4                                      case 0: ADDR2=0; ADDR1=0; ADDR0=0; i++; P0=LedBuff[0]; break;
  60   4                                      case 1: ADDR2=0; ADDR1=0; ADDR0=1; i++; P0=LedBuff[1]; break;
  61   4                                      case 2: ADDR2=0; ADDR1=1; ADDR0=0; i++; P0=LedBuff[2]; break;
  62   4                                      case 3: ADDR2=0; ADDR1=1; ADDR0=1; i++; P0=LedBuff[3]; break;
  63   4                                      case 4: ADDR2=1; ADDR1=0; ADDR0=0; i++; P0=LedBuff[4]; break;
  64   4                                      case 5: ADDR2=1; ADDR1=0; ADDR0=1; i=0; P0=LedBuff[5]; break;
  65   4                                      default: break;
  66   4                              }
  67   3                      }
  68   2              }
  69   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    431    ----
   CONSTANT SIZE    =     16    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      6       7
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
