C51 COMPILER V9.02   MAIN                                                                  03/11/2020 00:43:14 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: D:\Program Files (x86)\Keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*      变更lesson5_3的正计数为倒计数   */
   2          #include<reg52.h>
   3          
   4          sbit ADDR0 = P1^0;
   5          sbit ADDR1 = P1^1;
   6          sbit ADDR2 = P1^2;
   7          sbit ADDR3 = P1^3;
   8          sbit ENLED = P1^4;
   9          
  10          //用数组来存储数码管的真值表，数组将在下一章详细介绍
  11          unsigned char code LedChar[] = {
  12                  0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8,
  13                  0x80, 0x90, 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E
  14          };
  15          
  16          void main()
  17          {
  18   1              unsigned char cnt = 0;          //记录T0中断次数
  19   1              unsigned char sec = 0x0F;       //记录经过的秒数，倒计数初值0x0F(15)
  20   1      
  21   1              ENLED = 0;              //使能U3，选择数码管DS1
  22   1              ADDR3 = 1;
  23   1              ADDR2 = 0;
  24   1              ADDR1 = 0;
  25   1              ADDR0 = 0;
  26   1      
  27   1              TMOD = 0x01;    //设置T0为模式1
  28   1              TH0 = 0xB0;             //为T0赋初值0xB800
  29   1              TL0 = 0x00;             
  30   1              TR0 = 1;                //启动T0
  31   1      
  32   1              while(1)
  33   1              {
  34   2                      if( TF0 == 1 )                          //判断T0是否溢出
  35   2                      {
  36   3                              TF0 = 0;                                //T0溢出后，清零中断标志
  37   3                              TH0 = 0xB0;                             //并重新赋初值
  38   3                              TL0 = 0x00;
  39   3                              cnt++;                                  //计数值自加1
  40   3                              if( cnt >= 50 )                 //判断T0溢出是否达到50次
  41   3                              {
  42   4                                      cnt = 0;                        //达到50次后计数值清零
  43   4                                      P0 = LedChar[sec];      //当前秒数对应的真值表中的值送到P0口
  44   4                                      if( sec > 0 )           //当秒数大于0时，减1
  45   4                                      {
  46   5                                              sec--;
  47   5                                      }
  48   4                                      else                            //当秒数等于0时，重新赋初值0x0F
  49   4                                      {
  50   5                                              sec = 0x0F;
  51   5                                      }
  52   4                              }
  53   3                      }
  54   2              }
  55   1      }
C51 COMPILER V9.02   MAIN                                                                  03/11/2020 00:43:14 PAGE 2   



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =     64    ----
   CONSTANT SIZE    =     16    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
